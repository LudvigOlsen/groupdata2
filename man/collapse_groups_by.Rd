% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collapse_groups_by.R
\name{collapse_groups_by}
\alias{collapse_groups_by}
\alias{collapse_groups_by_size}
\alias{collapse_groups_by_numeric}
\alias{collapse_groups_by_levels}
\alias{collapse_groups_by_ids}
\title{Collapse groups balanced by a single attribute}
\usage{
collapse_groups_by_size(
  data,
  n,
  group_cols,
  method = "balance",
  extreme_pairing_levels = 1,
  col_name = ".coll_groups"
)

collapse_groups_by_numeric(
  data,
  n,
  group_cols,
  num_col = NULL,
  method = "balance",
  group_aggregation_fn = mean,
  extreme_pairing_levels = 1,
  col_name = ".coll_groups"
)

collapse_groups_by_levels(
  data,
  n,
  group_cols,
  cat_col = NULL,
  cat_levels = ".majority",
  method = "balance",
  extreme_pairing_levels = 1,
  col_name = ".coll_groups"
)

collapse_groups_by_ids(
  data,
  n,
  group_cols,
  id_col,
  method = "balance",
  extreme_pairing_levels = 1,
  col_name = ".coll_groups"
)
}
\arguments{
\item{data}{\code{data.frame}. Can be \emph{grouped}, in which case
the function is applied group-wise.}

\item{n}{Number of new groups.}

\item{group_cols}{Name(s) of factor(s) in \code{`data`} for identifying the existing groups
that should be collapsed.

Multiple names are treated as in \code{\link[dplyr:group_by]{dplyr::group_by()}}
(i.e., a hierarchy of groups), where each leaf group within each parent group is
considered a unique group to be collapsed.
Parent groups are not considered during collapsing, why leaf groups from different
parent groups can be collapsed together.

N.B. Do not confuse these group columns with potential columns that \code{`data`} is grouped by.
\code{`group_cols`} identifies the groups to be collapsed. When \code{`data`} is
grouped with \code{\link[dplyr:group_by]{dplyr::group_by()}}, the function is
applied separately to each of those subsets.}

\item{method}{\code{"balance"}, \code{"ascending"}, or \code{"descending"}.
\itemize{
\item \code{"balance"} balances the attribute between the groups.
\item \code{"ascending"} orders the attribute and groups from the lowest to highest value.
\item \code{"descending"} orders the attribute and groups from the highest to lowest value.
}}

\item{extreme_pairing_levels}{How many levels of extreme pairing to do
when balancing the groups by the combined balancing column (see \code{Details}).

\strong{Extreme pairing}: Rows/pairs are ordered as smallest, largest,
second smallest, second largest, etc. If \code{extreme_pairing_levels > 1},
this is done "recursively" on the extreme pairs.

N.B. Larger values work best with large datasets. If set too high,
the result might not be stochastic. Always check if an increase
actually makes the groups more balanced.}

\item{group_aggregation_fn}{Function for aggregating values in the \code{`num_cols`}
for each group in \code{`group_cols`} before balancing the \code{`num_cols`}.

N.B. Only used when \code{`num_cols`} is specified.}

\item{cat_col}{Name of categorical column to balance the average frequency
of one or more levels of between groups.}

\item{cat_levels}{Names of the levels in the \code{`cat_col`} column to balance the average frequency
of. The balancing will likely work best with fewer levels.

When \code{`NULL`}, all levels are balanced.

Can be a named numeric vector, where the names are the levels and the values are weights
of importance in the balancing.

E.g. \code{c("dog" = 5, "pidgeon" = 1, "mouse" = 3)} (the weights
are automatically scaled to sum to \code{1}).

Can be \code{".minority"} or \code{".majority"}, in which cases the minority/majority level
are found and used.}

\item{id_col}{Name of factor column with IDs to balance the counts of between groups.}
}
\value{
\code{`data`} with a new grouping factor column,
grouped by the existing grouping plus the new column.
}
\description{
\Sexpr[results=rd, stage=render]{lifecycle::badge("experimental")}

Collapses a set of groups into a smaller set of groups.

Balance the new groups by:
\itemize{
\item The \strong{number of rows} with \code{collapse_groups_by_size()}
\item A \strong{numerical column} with \code{collapse_groups_by_numeric()}
\item One or more levels of a \strong{categorical column} with \code{collapse_groups_by_levels()}
\item Level counts in an \strong{ID column} with \code{collapse_groups_by_ids()}
\item \strong{Any combination} of these with \code{collapse_groups()}
}

These functions wrap \code{\link[groupdata2:collapse_groups]{collapse_groups()}}. They
simplify the given tasks and provide additional methods. To balance more than one of
the attributes at a time, use \code{\link[groupdata2:collapse_groups]{collapse_groups()}}
directly.

Tip: Check the balances of the new groups with
\code{\link[groupdata2:summarize_balances]{summarize_balances()}}.
}
\examples{
# Attach packages
}
\seealso{
Other grouping functions: 
\code{\link{all_groups_identical}()},
\code{\link{collapse_groups}()},
\code{\link{fold}()},
\code{\link{group_factor}()},
\code{\link{group}()},
\code{\link{partition}()},
\code{\link{splt}()}
}
\author{
Ludvig Renbo Olsen, \email{r-pkgs@ludvigolsen.dk}
}
\concept{grouping functions}
