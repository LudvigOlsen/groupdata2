% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/splt.R
\name{splt}
\alias{splt}
\title{Split data by a range of methods}
\usage{
splt(
  data,
  n,
  method = "n_dist",
  starts_col = NULL,
  force_equal = FALSE,
  allow_zero = FALSE,
  descending = FALSE,
  randomize = FALSE,
  remove_missing_starts = FALSE
)
}
\arguments{
\item{data}{\code{data.frame} or \code{vector}.
When a \emph{grouped} \code{data.frame}, the function is applied group-wise.}

\item{n}{\emph{Depends on \code{`method`}.}

Number of groups (default), group size, list of group sizes,
list of group starts, number of data points between group members,
step size or prime number to start at. See \code{`method`}.

Passed as whole number(s) and/or percentage(s) (\code{0} < \code{n} < \code{1})
and/or character.

Method \code{"l_starts"} allows \code{'auto'}.}

\item{method}{\code{"greedy"}, \code{"n_dist"}, \code{"n_fill"}, \code{"n_last"},
\code{"n_rand"}, \code{"l_sizes"}, \code{"l_starts"}, \code{"every"}, \code{"staircase"}, or
\code{"primes"}.

\strong{Note}: examples are sizes of the generated groups
based on a vector with \code{57} elements.

\subsection{greedy}{Divides up the data greedily given a specified group size
\eqn{(e.g. 10, 10, 10, 10, 10, 7)}.

\code{`n`} is group size.}

\subsection{n_dist (default)}{Divides the data into a specified number of groups and
distributes excess data points across groups
\eqn{(e.g. 11, 11, 12, 11, 12)}.

\code{`n`} is number of groups.}

\subsection{n_fill}{Divides the data into a specified number of groups and
fills up groups with excess data points from the beginning
\eqn{(e.g. 12, 12, 11, 11, 11)}.

\code{`n`} is number of groups.}

\subsection{n_last}{Divides the data into a specified number of groups.
It finds the most equal group sizes possible,
using all data points. Only the last group is able to differ in size
\eqn{(e.g. 11, 11, 11, 11, 13)}.

\code{`n`} is number of groups.}

\subsection{n_rand}{Divides the data into a specified number of groups.
Excess data points are placed randomly in groups (max. 1 per group)
\eqn{(e.g. 12, 11, 11, 11, 12)}.

\code{`n`} is number of groups.}

\subsection{l_sizes}{Divides up the data by a \code{list} of group sizes.
Excess data points are placed in an extra group at the end.

\eqn{E.g. n = list(0.2, 0.3) outputs groups with sizes (11, 17, 29)}.

\code{`n`} is a \code{list} of group sizes.}

\subsection{l_starts}{Starts new groups at specified values in the \code{`starts_col`} vector.

\code{n} is a \code{list} of starting positions.
Skip values by \code{c(value, skip_to_number)} where \code{skip_to_number} is the
nth appearance of the value in the vector after the previous group start.
The first data point is automatically a starting position.

\eqn{E.g. n = c(1, 3, 7, 25, 50) outputs groups with sizes (2, 4, 18, 25, 8)}.

To skip: \eqn{given vector c("a", "e", "o", "a", "e", "o"), n = list("a", "e", c("o", 2))
 outputs groups with sizes (1, 4, 1)}.}

If passing \eqn{n = 'auto'} the starting positions are automatically found
such that a group is started whenever a value differs from the previous value
(see \code{\link{find_starts}()}).
Note that all \code{NA}s are first replaced by a single unique value,
meaning that they will also cause group starts.
See \code{\link{differs_from_previous}()}
to set a threshold for what is considered "different".

\eqn{E.g. n = "auto" for c(10, 10, 7, 8, 8, 9) would start groups at
 the first 10, 7, 8 and 9, and give c(1, 1, 2, 3, 3, 4).}

\subsection{every}{Combines every \code{`n`}th data point into a group.
\eqn{(e.g. 12, 12, 11, 11, 11 with n = 5)}.

\code{`n`} is the number of data points between group members ("every n").}

\subsection{staircase}{Uses step size to divide up the data.
Group size increases with 1 step for every group,
until there is no more data
\eqn{(e.g. 5, 10, 15, 20, 7)}.

\code{`n`} is step size.}

\subsection{primes}{Uses prime numbers as group sizes.
Group size increases to the next prime number
until there is no more data.
\eqn{(e.g. 5, 7, 11, 13, 17, 4)}.

\code{`n`} is the prime number to start at.}}

\item{starts_col}{Name of column with values to match in method \code{"l_starts"}
when \code{`data`} is a \code{data.frame}. Pass \code{'index'} to use row names. (Character)}

\item{force_equal}{Create equal groups by discarding excess data points.
Implementation varies between methods. (Logical)}

\item{allow_zero}{Whether \code{`n`} can be passed as \code{0}.
Can be useful when programmatically finding \code{n}. (Logical)}

\item{descending}{Change the direction of the method. (Not fully implemented)
(Logical)}

\item{randomize}{Randomize the grouping factor. (Logical)}

\item{remove_missing_starts}{Recursively remove elements from the
list of starts that are not found.
For method \code{"l_starts"} only.
(Logical)}
}
\value{
\code{list} of the split \code{`data`}.

\strong{N.B.} If \code{`data`} is a \emph{grouped} \code{data.frame}, there's an outer list
for each group. The names are based on the group indices
(see \code{\link[dplyr:group_data]{dplyr::group_indices()}}).
}
\description{
\Sexpr[results=rd, stage=render]{lifecycle::badge("stable")}

Divides data into groups by a wide range of methods.
Splits data by these groups.

Wraps \code{\link[groupdata2:group]{group()}} with \code{\link[base:split]{split()}}.
}
\examples{
# Attach packages
library(groupdata2)
library(dplyr)

# Create data frame
df <- data.frame(
  "x" = c(1:12),
  "species" = factor(rep(c("cat", "pig", "human"), 4)),
  "age" = sample(c(1:100), 12)
)

# Using splt()
df_list <- splt(df, 5, method = "n_dist")
}
\seealso{
Other grouping functions: 
\code{\link{all_groups_identical}()},
\code{\link{collapse_groups}()},
\code{\link{fold}()},
\code{\link{group_factor}()},
\code{\link{group}()},
\code{\link{partition}()}
}
\author{
Ludvig Renbo Olsen, \email{r-pkgs@ludvigolsen.dk}
}
\concept{grouping functions}
