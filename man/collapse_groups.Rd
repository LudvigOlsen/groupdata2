% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collapse_groups.R
\name{collapse_groups}
\alias{collapse_groups}
\title{Collapse groups with categorical, numerical, ID, and size balancing}
\usage{
collapse_groups(
  data,
  n,
  group_cols,
  cat_cols = NULL,
  cat_levels = NULL,
  num_cols = NULL,
  id_cols = NULL,
  balance_size = TRUE,
  auto_tune = FALSE,
  weights = NULL,
  method = "balance",
  group_aggregation_fn = mean,
  num_new_group_cols = 1,
  unique_new_group_cols_only = TRUE,
  max_iters = 5,
  extreme_pairing_levels = 1,
  combine_method = "avg_standardized",
  col_name = ".coll_groups",
  parallel = FALSE
)
}
\arguments{
\item{data}{\code{data.frame}. Can be \emph{grouped}, in which case
the function is applied group-wise.}

\item{n}{Number of new groups.

When \code{`num_new_group_cols` > 1}, \code{`n`} can also be a vector
with one \code{`n`} per new group column. This allows trying multiple \code{`n`}
settings at a time. Note that the generated group columns are not guaranteed
to be in the order of \code{`n`}.}

\item{group_cols}{Name(s) of factor(s) in \code{`data`} for identifying the \emph{existing} groups
that should be collapsed.

Multiple names are treated as in \code{\link[dplyr:group_by]{dplyr::group_by()}}
(i.e., a hierarchy of groups), where each leaf group within each parent group is
considered a unique group to be collapsed.
Parent groups are not considered during collapsing, why leaf groups from different
parent groups can be collapsed together.

N.B. Do not confuse these group columns with potential columns that \code{`data`} is grouped by.
\code{`group_cols`} identifies the groups to be collapsed. When \code{`data`} is
grouped with \code{\link[dplyr:group_by]{dplyr::group_by()}}, the function is
applied separately to each of those subsets.}

\item{cat_cols}{Name(s) of categorical column(s) to balance the average frequency
of one or more levels of.}

\item{cat_levels}{Names of the levels in the \code{`cat_cols`} columns to balance the average frequencies
of. Either a \code{vector} with level names, a named \code{numeric vector} with weights, or a named
\code{list} with \code{vector}s for each column name in \code{`cat_cols`}. When \code{`NULL`},
all levels are balanced.

For each of the columns in \code{`cat_cols`}, we either provide the level names or
weights for each of the levels, named by the level names.

E.g. \code{c("dog", "pidgeon", "mouse")} or \code{c("dog" = 5, "pidgeon" = 1, "mouse" = 3)} (the weights
are automatically scaled to sum to \code{1}).

When \code{`cat_cols`} has multiple column names, a named \code{list} with a \code{vector}
for each column, named by the column name. When not providing a \code{vector} for a \code{`cat_cols`}
column, all levels are balanced in that column.

E.g. \code{list("col1" = c("dog" = 5, "pidgeon" = 1, "mouse" = 3),
 "col2" = c("hydrated", "dehydrated"))}.

Can be \code{".minority"} or \code{".majority"}, in which case the minority/majority level
are found and used.}

\item{num_cols}{Name(s) of numerical column(s) to balance between groups.}

\item{id_cols}{Name(s) of factor column(s) with IDs to balance the counts of between groups.}

\item{balance_size}{Whether to balance the size of the collapsed groups. (logical)}

\item{auto_tune}{Whether to create a larger set of collapsed group columns
from all combinations of the balancing dimensions and select the
overall most balanced group column(s).

This tends to create much more balanced collapsed group columns.

Can be slow, why we recommend enabling parallelization (see \code{`parallel`}).}

\item{weights}{Named vector with weights of balancing importance for each of
the balancing dimensions. Besides the columns in \code{`cat_cols`}, \code{`num_cols`}, and \code{`ids_cols`},
the \emph{size} balancing weight can be given as \code{"size"}.

The weights are automatically scaled to sum to \code{1}.

Dimensions that are not given a weight is automatically given the weight \code{1}.

E.g. \code{c("size" = 1, "cat" = 1, "num" = 4, "id" = 2)}.}

\item{method}{\code{"balance"}, \code{"ascending"}, or \code{"descending"}.
\itemize{
\item \code{"balance"} balances the balancing columns between the groups.
\item \code{"ascending"} orders the combined balancing column and groups from the lowest to highest value.
\item \code{"descending"} orders the combined balancing column and groups from the highest to lowest value.
}}

\item{group_aggregation_fn}{Function for aggregating values in the \code{`num_cols`}
for each group in \code{`group_cols`} before balancing the \code{`num_cols`}.

N.B. Only used when \code{`num_cols`} is specified.}

\item{num_new_group_cols}{Number of group columns to create.

If \code{`num_new_group_cols` > 1}, columns will be named
with a combination of \code{`col_name`} and \code{"_1"}, \code{"_2"}, etc.
E.g. \eqn{".coll_groups_1"}, \eqn{".coll_groups_2"}, etc.

N.B. If \code{`unique_new_group_cols_only`} is \code{`TRUE`},
we can end up with fewer columns than specified, see \code{`max_iters`}.}

\item{unique_new_group_cols_only}{Check if new group columns are identical and
keep only unique columns.

As the number of column comparisons can be quite time consuming,
we can run this part in parallel. See \code{`parallel`}.

N.B. We can end up with fewer columns than specified in
\code{`num_new_group_cols`}, see \code{`max_iters`}.

N.B. Only used when \code{`num_new_group_cols` > 1}.}

\item{max_iters}{Maximum number of attempts at reaching
\code{`num_new_group_cols`} \emph{unique} new group columns.

When only keeping unique new group columns, we risk having fewer columns than expected.
Hence, we repeatedly create the missing columns and remove those that are not unique.
This is done until we have \code{`num_new_group_cols`} unique group columns
or we have attempted \code{`max_iters`} times.

In some cases, it is not possible to create \code{`num_new_group_cols`}
unique combinations of the dataset.
\code{`max_iters`} specifies when to stop trying.
Note that we can end up with fewer columns than specified in \code{`num_new_group_cols`}.

N.B. Only used when \code{`num_new_group_cols` > 1}.}

\item{extreme_pairing_levels}{How many levels of extreme pairing to do
when balancing the groups by the combined balancing column (see \code{Details}).

\strong{Extreme pairing}: Rows/pairs are ordered as smallest, largest,
second smallest, second largest, etc. If \code{extreme_pairing_levels > 1},
this is done "recursively" on the extreme pairs.

N.B. Larger values work best with large datasets. If set too high,
the result might not be stochastic. Always check if an increase
actually makes the groups more balanced.}

\item{combine_method}{Method to combine the balancing columns by.
One of \code{"avg_standardized"} or \code{"avg_min_max_scaled"}.

For each balancing dimension (\emph{size}, \emph{numeric}, \emph{categorical},
and \emph{ID}), we calculate a \emph{balancing column}, which indicates the
"size" of each group in that dimension. We then combine these columns in two steps:
\enumerate{
\item We normalize them separately with standardization (\code{"avg_standardized"}; Default) or MinMax scaling
to the [0, 1] range (\code{"avg_min_max_scaled"}).
\item We average them rowwise to get a single column with one value per group. The averaging
is weighted by \code{`weights`}, which is useful when one of the dimensions is
more important to get a good balance of.
}

\code{`combine_method`} chooses whether to use standardization or MinMax scaling in step 1.}

\item{parallel}{Whether to parallelize the group column comparisons,
when \code{`unique_new_group_cols_only`} is \code{TRUE}.

Requires a registered parallel backend.
Like \code{doParallel::registerDoParallel}.}
}
\value{
\code{data.frame} with one or more new grouping factors.
}
\description{
\Sexpr[results=rd, stage=render]{lifecycle::badge("experimental")}

Collapses a set of groups into a smaller set of groups.

Balance the new groups by numerical columns,
categorical columns,
level counts in ID columns,
and/or the number of rows (size).

\strong{Note}: The more of these you balance at a time,
the less balanced each of them may become. While on average,
the balancing work better than without, this is
not guaranteed on every run. Enabling \code{`auto_tune`} should yield a
much better overall balance than without in most contexts.
This generates a larger set of group columns using all combinations of the
balancing columns and selects the most balanced group column(s).
This is slower and we recommend enabling parallelization (see \code{`parallel`}).

\strong{Tip}: Check the balances of the new groups with
\code{\link[groupdata2:summarize_balances]{summarize_balances()}}.
}
\details{
The goal of \code{collapse_groups()} is to combine existing groups
to a lower number of groups while (optionally) balancing one or more of
four "balancing dimensions" (\emph{size}, \emph{numeric}, \emph{categorical},
and/or \emph{ID}). From each of these dimensions, we calculate
a normalized, numeric \emph{"balancing column"} that when balanced
between the groups lead to its dimension being balanced as well.

To balance multiple dimensions at once, we combine their balancing columns with
with weighted averaging (see \code{`combine_method`} and \code{`weights`}).

Finally, we create groups where this combined balancing column is balanced using the
numerical balancing in \code{\link[groupdata2:fold]{fold()}}.

\subsection{Auto-tuning}{

This strategy is not guaranteed to produce balanced groups in all contexts,
e.g. when the balancing columns cancel out. To increase the probability of
balanced groups, we can produce multiple group columns with all combinations
of the balancing dimensions and select the overall most balanced group column(s).
We refer to this as auto-tuning (see \code{`auto_tune`}).

We find the most balanced group column from the rankings of across-group
standard deviations for each of the balancing dimensions, using the summaries produced by
\code{\link[groupdata2:summarize_balances]{summarize_balances()}}. E.g. if for
a group column the groups have the following average \emph{ages} \code{`c(16, 18, 25, 21)`},
the standard deviation thereof (\code{3.92}) is our measure for how balanced the \emph{age}
column is. Another group column can thus have a lower/higher standard deviation.
We find the rankings of these standard deviations for all the balancing dimensions
and average them (again weighted by \code{`weights`}). We select the, on average, highest ranking
(i.e. lowest standard deviations) group column(s).

}\subsection{Checking balances}{

We highly recommend using
\code{\link[groupdata2:summarize_balances]{summarize_balances()}} to
check how balanced the created groups are on the various dimensions.
By applying \code{\link[groupdata2:ranked_balances]{ranked_balances()}}
to the summaries, we get a \code{data.frame} with the standard deviations
for each balancing dimension, ordered by the average rank.

}\subsection{Balancing columns}{

The following describes the creation of the balancing columns
for each of the balancing dimensions:

\subsection{cat_cols}{
For each column in \code{`cat_cols`}:
\itemize{
\item \strong{Count each level} in each group. This creates a \code{data.frame} with
one count column per level, with one row per group.
\item \strong{Standardize} the count columns.
\item \strong{Sum} the standardized counts rowwise to create one combined column representing
the balance of the levels for each group.
}

\strong{Example}: Consider a factor column with the levels \code{c("A", "B", "C")}.
We count each level per group, normalize the counts and combine them with weighted averaging:

\tabular{rrrrrrrrrr}{
\strong{Group} \tab \strong{A} \tab
\strong{B} \tab \strong{C} \tab
\strong{ -> } \tab \strong{nA} \tab
\strong{nB} \tab \strong{nC} \tab
\strong{ -> } \tab \strong{Combined}\cr
1 \tab 5 \tab 57 \tab 1 \tab | \tab 0.24 \tab 0.55 \tab -0.77 \tab | \tab 0.007  \cr
2 \tab 7 \tab 69 \tab 2 \tab | \tab 0.93 \tab 0.64 \tab -0.77 \tab | \tab 0.267 \cr
3 \tab 2 \tab 34 \tab 14\tab | \tab -1.42\tab 0.29 \tab 1.34  \tab | \tab 0.07 \cr
4 \tab 5 \tab 0 \tab 4  \tab | \tab 0.24 \tab -1.48\tab 0.19  \tab | \tab -0.35 \cr
... \tab ... \tab ... \tab ... \tab | \tab ... \tab ... \tab ... \tab | \tab ... }

}

\subsection{id_cols}{
For each column in \code{`id_cols`}:
\itemize{
\item \strong{Count} the unique IDs (levels) within each group.
(Note: The same ID can be counted in multiple groups.)
}
}

\subsection{num_cols}{
For each column in \code{`num_cols`}:
\itemize{
\item \strong{Aggregate} the numeric columns by group using the \code{`group_aggregation_fn`}.
}
}

\subsection{size}{
\itemize{
\item \strong{Count} the number of rows per group.
}
}

\subsection{Combining balancing columns}{
\itemize{
\item Apply standardization or MinMax scaling to each of the balancing columns (see \code{`combine_method`}).
\item Perform weighted averaging to get a single balancing column (see \code{`weights`}).
}

\strong{Example}: We apply standardization and perform weighted averaging:

\tabular{rrrrrrrrrrrr}{
\strong{Group} \tab \strong{Size} \tab
\strong{Num} \tab \strong{Cat} \tab
\strong{ID} \tab \strong{->} \tab
\strong{nSize} \tab \strong{nNum}
\tab \strong{nCat} \tab \strong{nID} \tab
\strong{->} \tab \strong{Combined}\cr
1 \tab 34 \tab 1.3 \tab 0.007 \tab 3 \tab | \tab -0.33 \tab -0.82 \tab 0.03 \tab -0.46\tab | \tab -0.395  \cr
2 \tab 23 \tab 4.6 \tab 0.267 \tab 4 \tab | \tab -1.12 \tab 0.34  \tab 1.04 \tab 0.0  \tab | \tab 0.065 \cr
3 \tab 56 \tab 7.2 \tab 0.07  \tab 7 \tab | \tab 1.27  \tab 1.26  \tab 0.28 \tab 1.39 \tab | \tab 1.05 \cr
4 \tab 41 \tab 1.4 \tab -0.35 \tab 2 \tab | \tab 0.18  \tab -0.79 \tab -1.35\tab -0.93\tab | \tab -0.723 \cr
... \tab ... \tab ... \tab ... \tab ... \tab |
\tab ... \tab ... \tab ... \tab ... \tab | \tab ... }

}

}\subsection{Creating the groups}{

Finally, we get to the group creation. There are three methods for creating groups based on the
combined balancing column: "balance", "ascending", and "descending".

\subsection{\code{method} is "balance"}{
To create groups that are balanced by the combined balancing column, we use the numerical balancing
in \code{\link[groupdata2:fold]{fold()}}.

The following describes the numerical balancing in broad terms:

\enumerate{
\item Rows are shuffled.
\strong{Note} that this will only affect rows with the same value in the combined balancing column.
\item Extreme pairing 1: Rows are ordered as \emph{smallest, largest, second smallest, second largest}, etc.
Each pair get a group identifier. (See \code{\link[rearrr:pair_extremes]{rearrr::pair_extremes()}})
\item If \code{`extreme_pairing_levels` > 1}: These group identifiers are reordered as \emph{smallest,
largest, second smallest, second largest}, etc., by the sum of the combined balancing column in the represented rows.
These pairs (of pairs) get a new set of group identifiers, and the process is repeated
\code{`extreme_pairing_levels`-2} times. Note that the group identifiers at the last level will represent
\code{2^`extreme_pairing_levels`} rows, why you should be careful when choosing that setting.
\item The group identifiers from the last pairing are randomly divided into the final groups,
and these final identifiers are transferred to the original rows.
}

N.B. When doing extreme pairing of an unequal number of rows,
the row with the smallest value is placed in a group by itself, and the order is instead:
smallest, \emph{second smallest, largest, third smallest, second largest}, etc.

\strong{Example}: We order the \code{data.frame} by smallest \emph{"Num"} value,
largest \emph{"Num"} value, second smallest, and so on.
We could further (when \code{`extreme_pairing_levels` > 1})
find the sum of \emph{"Num"} for each pair and perform extreme pairing on the pairs.
Finally, we group the \code{data.frame}:

\tabular{rrrrrrrrrrrr}{
\strong{Group} \tab \strong{Num} \tab
\strong{->} \tab
\strong{Group} \tab \strong{Num} \tab
\strong{Pair} \tab \strong{->} \tab
\strong{New group}\cr
1 \tab -0.395\tab | \tab 5 \tab -1.23 \tab 1 \tab | \tab 3 \cr
2 \tab 0.065 \tab | \tab 3 \tab 1.05  \tab 1 \tab | \tab 3 \cr
3 \tab 1.05  \tab | \tab 4 \tab -0.723\tab 2 \tab | \tab 1 \cr
4 \tab -0.723\tab | \tab 2 \tab 0.065 \tab 2 \tab | \tab 1 \cr
5 \tab -1.23 \tab | \tab 1 \tab -0.395\tab 3 \tab | \tab 2 \cr
6 \tab -0.15 \tab | \tab 6 \tab -0.15 \tab 3 \tab | \tab 2 \cr
... \tab ... \tab | \tab ... \tab ... \tab ... \tab | \tab ... }

}

\subsection{\code{method} is "ascending" or "descending"}{
These methods order the data by the combined balancing column and
creates groups such that the sums get increasingly larger (\code{`ascending`})
or smaller (\code{`descending`}). This will in turn lead to a \emph{pattern} of
increasing/decreasing sums in the balancing columns (e.g. increasing/decreasing counts
of the categorical levels, counts of IDs, number of rows and sums of numeric columns).
}

}
}
\examples{
# Attach packages
library(groupdata2)
library(dplyr)

# Create data frame
df <- data.frame(
  "participant" = factor(rep(c("1", "2", "3", "4", "5", "6"), 3)),
  "age" = rep(sample(c(1:100), 6), 3),
  "diagnosis" = factor(rep(c("a", "b", "a", "a", "b", "b"), 3)),
  "score" = sample(c(1:100), 3 * 6)
)
df <- df \%>\% arrange(participant)
df$session <- rep(c("1", "2", "3"), 6)





}
\seealso{
\code{\link[groupdata2:fold]{fold()}} for creating balanced folds/groups.

\code{\link[groupdata2:partition]{partition()}} for creating balanced partitions.

Other grouping functions: 
\code{\link{all_groups_identical}()},
\code{\link{collapse_groups_by}},
\code{\link{fold}()},
\code{\link{group_factor}()},
\code{\link{group}()},
\code{\link{partition}()},
\code{\link{splt}()}
}
\author{
Ludvig Renbo Olsen, \email{r-pkgs@ludvigolsen.dk}
}
\concept{grouping functions}
