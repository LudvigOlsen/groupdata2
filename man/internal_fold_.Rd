% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fold.R
\name{internal_fold_}
\alias{internal_fold_}
\title{Internal version of \code{`fold()`}}
\usage{
internal_fold_(
  data,
  k = 5,
  cat_col = NULL,
  num_col = NULL,
  id_col = NULL,
  method = "n_dist",
  id_aggregation_fn = sum,
  extreme_pairing_levels = 1,
  use_of_triplets = "fill",
  num_fold_cols = 1,
  unique_fold_cols_only = TRUE,
  max_iters = 5,
  handle_existing_fold_cols = "keep_warn",
  parallel = FALSE
)
}
\arguments{
\item{data}{\code{data.frame}. Can be \emph{grouped}, in which case
the function is applied group-wise.}

\item{k}{\emph{Depends on \code{`method`}.}

Number of folds (default), fold size, with more (see \code{`method`}).

When \code{`num_fold_cols` > 1}, \code{`k`} can also be a vector
with one \code{`k`} per fold column. This allows trying multiple \code{`k`} settings at a time. Note
that the generated fold columns are not guaranteed to be in the order of \code{`k`}.

Given as whole number or percentage (\code{0 < `k` < 1}).}

\item{cat_col}{Name of categorical variable to balance between folds.

E.g. when predicting a binary variable (a or b), we usually want
both classes represented in every fold.

N.B. If also passing an \code{`id_col`}, \code{`cat_col`} should be constant within each ID.}

\item{num_col}{Name of numerical variable to balance between folds.

N.B. When used with \code{`id_col`}, values for each ID are aggregated using
\code{`id_aggregation_fn`} before being balanced.

N.B. When passing \code{`num_col`}, the \code{`method`} parameter is ignored.}

\item{id_col}{Name of factor with IDs.
This will be used to keep all rows that share an ID in the same fold
(if possible).

E.g. If we have measured a participant multiple times and want to see the
effect of time, we want to have all observations of this participant in
the same fold.

N.B. When \code{`data`} is a \emph{grouped} \code{data.frame}
(see \code{\link[dplyr:group_by]{dplyr::group_by()}}), IDs that appear in multiple
groupings might end up in different folds in those groupings.}

\item{method}{\code{"n_dist"}, \code{"n_fill"}, \code{"n_last"},
\code{"n_rand"}, \code{"greedy"}, or \code{"staircase"}.

\strong{Notice}: examples are sizes of the generated groups
based on a vector with \code{57} elements.

\subsection{n_dist (default)}{Divides the data into a specified number of groups and
distributes excess data points across groups
\eqn{(e.g. 11, 11, 12, 11, 12)}.

\code{`k`} is number of groups}

\subsection{n_fill}{Divides the data into a specified number of groups and
fills up groups with excess data points from the beginning
\eqn{(e.g. 12, 12, 11, 11, 11)}.

\code{`k`} is number of groups}

\subsection{n_last}{Divides the data into a specified number of groups.
It finds the most equal group sizes possible,
using all data points. Only the last group is able to differ in size
\eqn{(e.g. 11, 11, 11, 11, 13)}.

\code{`k`} is number of groups}

\subsection{n_rand}{Divides the data into a specified number of groups.
Excess data points are placed randomly in groups (only 1 per group)
\eqn{(e.g. 12, 11, 11, 11, 12)}.

\code{`k`} is number of groups}

\subsection{greedy}{Divides up the data greedily given a specified group size
\eqn{(e.g. 10, 10, 10, 10, 10, 7)}.

\code{`k`} is group size}

\subsection{staircase}{Uses step size to divide up the data.
Group size increases with 1 step for every group,
until there is no more data
\eqn{(e.g. 5, 10, 15, 20, 7)}.

\code{`k`} is step size}}

\item{id_aggregation_fn}{Function for aggregating values in \code{`num_col`}
for each ID, before balancing \code{`num_col`}.

N.B. Only used when \code{`num_col`} and \code{`id_col`} are both specified.}

\item{extreme_pairing_levels}{How many levels of extreme pairing to do
when balancing folds by a numerical column (i.e. \code{`num_col`} is specified).

\strong{Extreme pairing}: Rows/pairs are ordered as smallest, largest,
second smallest, second largest, etc. If \code{extreme_pairing_levels > 1},
this is done "recursively" on the extreme pairs. See \code{`Details/num_col`} for more.

N.B. Larger values work best with large datasets. If set too high,
the result might not be stochastic. Always check if an increase
actually makes the folds more balanced. See example.}

\item{use_of_triplets}{How to use extreme triplets in numeric balancing.
One of \code{'fill'}, \code{'instead'}, \code{'none'}.

When \code{'instead'}, extreme \emph{pairing} is replaced by extreme \emph{triplet grouping}.}

\item{num_fold_cols}{Number of fold columns to create.
Useful for repeated cross-validation.

If \code{num_fold_cols > 1}, columns will be named
\eqn{".folds_1"}, \eqn{".folds_2"}, etc.
Otherwise simply \eqn{".folds"}.

N.B. If \code{`unique_fold_cols_only`} is \code{TRUE},
we can end up with fewer columns than specified, see \code{`max_iters`}.

N.B. If \code{`data`} has existing fold columns, see \code{`handle_existing_fold_cols`}.}

\item{unique_fold_cols_only}{Check if fold columns are identical and
keep only unique columns.

As the number of column comparisons can be time consuming,
we can run this part in parallel. See \code{`parallel`}.

N.B. We can end up with fewer columns than specified in
\code{`num_fold_cols`}, see \code{`max_iters`}.

N.B. Only used when \code{`num_fold_cols` > 1} or \code{`data`} has existing fold columns.}

\item{max_iters}{Maximum number of attempts at reaching
\code{`num_fold_cols`} \emph{unique} fold columns.

When only keeping unique fold columns, we risk having fewer columns than expected.
Hence, we repeatedly create the missing columns and remove those that are not unique.
This is done until we have \code{`num_fold_cols`} unique fold columns
or we have attempted \code{`max_iters`} times.

In some cases, it is not possible to create \code{`num_fold_cols`}
unique combinations of the dataset, e.g.
when specifying \code{`cat_col`}, \code{`id_col`} and \code{`num_col`}.
\code{`max_iters`} specifies when to stop trying.
Note that we can end up with fewer columns than specified in \code{`num_fold_cols`}.

N.B. Only used when \code{`num_fold_cols` > 1}.}

\item{handle_existing_fold_cols}{How to handle existing fold columns.
Either \code{"keep_warn"}, \code{"keep"}, or \code{"remove"}.

To \strong{add} extra fold columns, use \code{"keep"} or \code{"keep_warn"}.
Note that existing fold columns might be renamed.

To \strong{replace} the existing fold columns, use \code{"remove"}.}

\item{parallel}{Whether to parallelize the fold column comparisons,
when \code{`unique_fold_cols_only`} is \code{TRUE}.

Requires a registered parallel backend.
Like \code{doParallel::registerDoParallel}.}
}
\description{
Internal version of \code{`fold()`} that allows setting the use of \code{triplets} and avoids
argument checks.
}
\keyword{internal}
