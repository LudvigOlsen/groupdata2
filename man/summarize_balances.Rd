% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/summarize_group_balances.R
\name{summarize_balances}
\alias{summarize_balances}
\title{Summarize group balances}
\usage{
summarize_balances(
  data,
  group_cols,
  cat_cols = NULL,
  num_cols = NULL,
  id_cols = NULL,
  include_normalized = FALSE,
  num_normalize_fn = function(x) {     rearrr::min_max_scale(x, new_min = 0, new_max =
    1) },
  max_cat_prefix_chars = "auto"
)
}
\arguments{
\item{data}{\code{data.frame}. Can be \emph{grouped}, in which case
the function is applied group-wise. !!!TODO Does this work currently?!!!}

\item{group_cols}{Names of columns to with groups to summarize.}

\item{cat_cols}{Names of categorical columns to summarize.

Each categorical level is counted per group.

To distinguish between levels with the same name from different
\code{`cat_col`} columns, we prefix the count column name for each
categorical level with parts of the name of the categorical column.
This amount can be controlled with \code{`max_cat_prefix_chars`}.

Normalization: The counts of each categorical level is normalized with \code{log(1 + count)}.}

\item{num_cols}{Names of numerical columns to summarize.

For each column, the \code{mean} and \code{sum} is calculated per group.

Normalization: Each column is normalized with \code{`num_normalize_fn`} before
calculating the \code{mean} and \code{sum} per group.}

\item{id_cols}{Names of factor columns with IDs to summarize.

The number of unique IDs are counted per group.

Normalization: The count of unique IDs is normalized with \code{log(1 + count)}.}

\item{include_normalized}{Whether to calculate and include the
normalized summary in the output. (logical)}

\item{num_normalize_fn}{Function for normalizing the \code{`num_cols`} columns before
calculating normalized group summaries.

Only used when \code{`include_normalized`} is enabled.}

\item{max_cat_prefix_chars}{How many characters to prefix the categorical level
column names with.

TODO Improve this - explain why and what!

\code{"auto"} finds the number of characters \code{>=4} necessary to distinguish
between column names in \code{`cat_cols`}. E.g. if \code{`cat_cols`} contains the
column names \code{c("xxxxxxx","xxxxxyy")}, we need the 6 first characters to
distinguish them from each other.}
}
\value{
\code{list} with three \code{data.frames}:

\subsection{Groups}{
A summary per group.

\code{`cat_cols`}: Each level has its own column with the count
of the level per group.

\code{`num_cols`}: The \code{mean} and \code{sum} per group.

\code{`id_cols`}: The count of unique IDs per group.
}

\subsection{Summary}{
Statistical descriptors of the columns in \code{`Group`}.

Contains the \code{mean}, \code{median}, standard deviation (\code{SD}),
interquartile range (\code{IQR}), \code{min}, and \code{max} measures.

Especially the standard deviations and IQR measures can tell us about how
balanced the groups are. When comparing multiple \code{`group_cols`},
the group column with the lowest \code{SD} and \code{IQR}
can be considered the most balanced.
}

\subsection{Normalized Summary}{
(Disabled by default)

Same statistical descriptors as in \code{`Summary`} but for a
"normalized" version of the group summaries. The motivation
is that these normalized measures can more easily be compared
or combined to a single "balance score".

First, we normalize each balance column:

\code{`cat_cols`}: The level counts in the original group summaries are
normalized with with \code{log(1 + count)}. This eases comparison
of the statistical descriptors (especially standard deviations)
of levels with very different count scales.

\code{`num_cols`}: The numerical columns are normalized prior to
summarization by group, using the \code{`num_normalize_fn`} function.
By default this applies MinMax scaling to columns so they are in the
range \code{[0, 1]}.
!!!TODO outliers can make them difficult to compare?!!!

\code{`id_cols`}: The counts of unique IDs in the original group summaries are
normalized with with \code{log(1 + count)}.

Contains the \code{mean}, \code{median}, standard deviation (\code{SD}),
interquartile range (\code{IQR}), \code{min}, and \code{max} measures.
}
}
\description{
\Sexpr[results=rd, stage=render]{lifecycle::badge("experimental")}

Summarize the balances of numeric, categorical, and ID columns
in and between groups in one or more group columns.

This tools allows you to quickly and thorughly assess the balance
of different columns between groups. This is for instance useful
after creating groups with \code{\link[groupdata2:fold]{fold()}},
\code{\link[groupdata2:partition]{partition()}}, or
\code{\link[groupdata2:collapse_groups]{collapse_groups()}} to
check their performance on your data.

The output contains:
\enumerate{
\item \code{`Groups`}: a summary per group.
\item \code{`Summary`}: statistical descriptors of the group summaries.
\item \code{`Normalized Summary`}: statistical descriptors of a set of
"normalized" group summaries. (Disabled by default)
}
}
\examples{
# Attach packages
library(groupdata2)
library(dplyr)

# Create data frame
df <- data.frame(
  "participant" = factor(rep(c("1", "2", "3", "4", "5", "6"), 3)),
  "age" = rep(sample(c(1:100), 6), 3),
  "diagnosis" = factor(rep(c("a", "b", "a", "a", "b", "b"), 3)),
  "score" = sample(c(1:100), 3 * 6)
)
df <- df \%>\% arrange(participant)
df$session <- rep(c("1", "2", "3"), 6)

# Using fold()

## Without balancing
df_folded <- fold(data = df, k = 3, method = "n_dist")

## With cat_col
df_folded <- fold(
  data = df,
  k = 3,
  cat_col = "diagnosis",
  method = "n_dist"
)
}
\seealso{
Other summarization functions: 
\code{\link{summarize_group_cols}()}
}
\author{
Ludvig Renbo Olsen, \email{r-pkgs@ludvigolsen.dk}
}
\concept{summarization functions}
