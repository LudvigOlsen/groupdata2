% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collapse_groups.R
\name{collapse_groups}
\alias{collapse_groups}
\title{Collapse groups with categorical, numerical, ID, and size balancing}
\usage{
collapse_groups(
  data,
  n,
  group_cols,
  cat_col = NULL,
  cat_levels = NULL,
  num_cols = NULL,
  id_col = NULL,
  balance_size = TRUE,
  auto_tune = FALSE,
  group_aggregation_fn = mean,
  num_new_group_cols = 1,
  unique_new_group_cols_only = TRUE,
  max_iters = 5,
  extreme_pairing_levels = 1,
  combine_method = "avg_standardized",
  weights = c(size = 1, cat = 1, num = 1, id = 1),
  col_name = ".coll_groups",
  parallel = FALSE
)
}
\arguments{
\item{data}{\code{data.frame}. Can be \emph{grouped}, in which case
the function is applied group-wise.}

\item{n}{Number of new groups.

When \code{`num_new_group_cols` > 1}, \code{`n`} can also be a vector
with one \code{`n`} per new group column. This allows trying multiple \code{`n`}
settings at a time. Note that the generated group columns are not guaranteed
to be in the order of \code{`n`}.}

\item{group_cols}{Name(s) of factor(s) in \code{`data`} for identifying the existing groups
that should be collapsed.

Multiple names are treated as in \code{\link[dplyr:group_by]{dplyr::group_by()}}
(i.e., a hierarchy of groups), where each leaf group within each parent group is
considered a unique group to be collapsed.
Parent groups are not considered during collapsing, why leaf groups from different
parent groups can be collapsed together.

N.B. Do not confuse these group columns with potential columns that \code{`data`} is grouped by.
\code{`group_cols`} identifies the groups to be collapsed. When \code{`data`} is
grouped with \code{\link[dplyr:group_by]{dplyr::group_by()}}, the function is
applied separately to each of those subsets.}

\item{cat_col}{Name of categorical column to balance the average frequency
of one or more levels of between groups.}

\item{cat_levels}{Names of the levels in the \code{`cat_col`} column to balance the average frequency
of. The balancing will likely work best with fewer levels.

When \code{`NULL`}, all levels are balanced.

Can be a named numeric vector, where the names are the levels and the values are weights
of importance in the balancing.

E.g. \code{c("dog" = 5, "pidgeon" = 1, "mouse" = 3)} (the weights
are automatically scaled to sum to \code{1}).

Can be \code{".minority"} or \code{".majority"}, in which cases the minority/majority level
are found and used.}

\item{num_cols}{Name(s) of numerical column(s) to balance between groups.}

\item{id_col}{Name of factor column with IDs to balance the counts of between groups.}

\item{balance_size}{Whether to balance the size of the collapsed groups. (logical)}

\item{group_aggregation_fn}{Function for aggregating values in the \code{`num_cols`}
for each group in \code{`group_cols`} before balancing the \code{`num_cols`}.

N.B. Only used when \code{`num_cols`} is specified.}

\item{num_new_group_cols}{Number of group columns to create.

If \code{`num_new_group_cols` > 1}, columns will be named
with a combination of \code{`col_name`} and \code{"_1"}, \code{"_2"}, etc.
E.g. \eqn{".coll_groups_1"}, \eqn{".coll_groups_2"}, etc.

N.B. If \code{`unique_new_group_cols_only`} is \code{`TRUE`},
we can end up with fewer columns than specified, see \code{`max_iters`}.
E.g. when using balancing, the max. possible number of unique
collapsings is often \code{1}. TODO DODODODODDODODODODO!!!!!}

\item{unique_new_group_cols_only}{Check if fold columns are identical and
keep only unique columns.

As the number of column comparisons can be time consuming,
we can run this part in parallel. See \code{`parallel`}.

N.B. We can end up with fewer columns than specified in
\code{`num_new_group_cols`}, see \code{`max_iters`}.

N.B. Only used when \code{`num_new_group_cols` > 1} or (TODODODO: \code{`data`} has existing group columns.)}

\item{max_iters}{Maximum number of attempts at reaching
\code{`num_new_group_cols`} \emph{unique} new group columns.

When only keeping unique new group columns, we risk having fewer columns than expected.
Hence, we repeatedly create the missing columns and remove those that are not unique.
This is done until we have \code{`num_new_group_cols`} unique group columns
or we have attempted \code{`max_iters`} times.
In some cases, it is not possible to create \code{`num_new_group_cols`}
unique combinations of the dataset.
\code{`max_iters`} specifies when to stop trying.
Note that we can end up with fewer columns than specified in \code{`num_new_group_cols`}.

N.B. Only used when \code{`num_new_group_cols` > 1}.}

\item{extreme_pairing_levels}{How many levels of extreme pairing to do
when balancing the groups by the combined balancing column (see \code{Details}).

\strong{Extreme pairing}: Rows/pairs are ordered as smallest, largest,
second smallest, second largest, etc. If \code{extreme_pairing_levels > 1},
this is done "recursively" on the extreme pairs.

N.B. Larger values work best with large datasets. If set too high,
the result might not be stochastic. Always check if an increase
actually makes the groups more balanced.}

\item{combine_method}{Method to combine the balancing columns by.
One of \code{"avg_standardized"} or \code{"avg_min_max_scaled"}.

For each balancing dimension (\emph{size}, \emph{numeric}, \emph{categorical},
and \emph{ID}), we calculate a \emph{balancing column}, which indicates the
"size" of each group in that dimension. We then combine these columns in two steps:
\enumerate{
\item We normalize them separately with standardization (\code{"avg_standardized"}; Default) or MinMax scaling
to the [0, 1] range (\code{"avg_min_max_scaled"}).
\item We average them rowwise to get a single column with one value per group. The averaging
is weighted by \code{`weights`}, which is useful when one of the dimensions is
more important to get a good balance of.
}

\code{`combine_method`} chooses whether to use standardization or MinMax scaling in step 1.}

\item{weights}{Named vector with weights of balancing importance for each of
the balancing dimensions. Can be used to favor balancing of
either balancing dimension (\emph{size}, \emph{numeric}, \emph{categorical},
or \emph{ID}).

E.g. \code{c("size" = 1, "cat" = 1, "num" = 4, "id" = 2)} (the weights
are automatically scaled to sum to \code{1}).}

\item{parallel}{Whether to parallelize the group column comparisons,
when \code{`unique_new_group_cols_only`} is \code{TRUE}.

Requires a registered parallel backend.
Like \code{doParallel::registerDoParallel}.}
}
\value{
\code{data.frame} with grouping factor for subsetting in cross-validation.
}
\description{
\Sexpr[results=rd, stage=render]{lifecycle::badge("experimental")}

Collapses a set of groups into a smaller set of groups.

Balance the new groups by a numerical column,
one or more levels of a categorical column,
level counts in an ID column,
and/or the number of rows (size).

Note: The more of these you balance at a time,
the less balanced each of them may become.

Tip: Check the balances of the new groups with
\code{\link[groupdata2:summarize_balances]{summarize_balances()}}.
}
\details{
The goal of \code{collapse_groups()} is to combine existing groups
to a lower number of groups while (optionally) balancing one or more of
four "balancing dimensions" (\emph{size}, \emph{numeric}, \emph{categorical},
and/or \emph{ID}). From each of these dimensions, we calculate
a normalized, numeric \emph{"balancing column"} that when balanced
between the groups means its dimension is balanced as well.

To balance multiple dimensions at once, we combine these balancing columns with
with weighted averaging (see \code{`combine_method`} and \code{`weights`}).

Finally, we create groups where this combined balancing column is balanced using the
numerical balancing in \code{\link[groupdata2:fold]{fold()}}.

While theoretically, there should be instances where this strategy fails to
produce balanced groups, e.g. if the balancing dimensions cancel out or when
balancing on too many things at once, \emph{in practice}, this tends to lead
to decent* balances of the included columns (*better than not applying balancing).

When the balancing is important, we recommend using
\code{\link[groupdata2:summarize_balances]{summarize_balances()}} to
check how balanced the created groups are on the various dimensions.
If they are not balanced enough, consider changing \code{`weights`} or
balancing fewer dimensions at a time.

The following describes the creation of the balancing columns
for each of the balancing dimensions:

\subsection{cat_col}{
\itemize{
\item \strong{Count each level} in each group. This creates a \code{data.frame} with
one count column per level, with one row per group.
\item \strong{Log-transform} the count columns with \code{log10(1 + count)}.
\item \strong{Standardize} the transformed count columns.
\item \strong{Sum} the standardized counts rowwise to create one combined column representing
the balance of the levels for each group.
}

\strong{Example}: Consider a factor column with the levels \code{c("A", "B", "C")}.
We count each level per group, normalize the counts and combine them with weighted averaging:

\tabular{rrrrrrrrrr}{
\strong{Group} \tab \strong{A} \tab
\strong{B} \tab \strong{C} \tab
\strong{ -> } \tab \strong{nA} \tab
\strong{nB} \tab \strong{nC} \tab
\strong{ -> } \tab \strong{Combined}\cr
1 \tab 5 \tab 57 \tab 1 \tab | \tab 0.24 \tab 0.55 \tab -0.77 \tab | \tab 0.007  \cr
2 \tab 7 \tab 69 \tab 2 \tab | \tab 0.93 \tab 0.64 \tab -0.77 \tab | \tab 0.267 \cr
3 \tab 2 \tab 34 \tab 14\tab | \tab -1.42\tab 0.29 \tab 1.34  \tab | \tab 0.07 \cr
4 \tab 5 \tab 0 \tab 4  \tab | \tab 0.24 \tab -1.48\tab 0.19  \tab | \tab -0.35 \cr
... \tab ... \tab ... \tab ... \tab | \tab ... \tab ... \tab ... \tab | \tab ... }

By default, we only use the normalized counts for the majority class.

}

\subsection{id_col}{
\itemize{
\item \strong{Count} the unique IDs (levels) within each group.
(Note: The same ID can be counted in multiple groups.)
}
}

\subsection{num_cols}{
\itemize{
\item \strong{Aggregate} the numeric columns by group using the \code{`group_aggregation_fn`}.
\item TODO Combine the aggregates !!!
}
}

\subsection{size}{
\itemize{
\item \strong{Count} the number of rows per group.
}
}

\subsection{Combining balancing columns}{
\itemize{
\item Apply standardization or MinMax scaling to each of the balancing columns (see \code{`combine_method`}).
\item Perform weighted averaging to get a single balancing column (see \code{`weights`}).
}

\strong{Example}: We apply standardization and perform weighted averaging:

\tabular{rrrrrrrrrrrr}{
\strong{Group} \tab \strong{Size} \tab
\strong{Num} \tab \strong{Cat} \tab
\strong{ID} \tab \strong{->} \tab
\strong{nSize} \tab \strong{nNum}
\tab \strong{nCat} \tab \strong{nID} \tab
\strong{->} \tab \strong{Combined}\cr
1 \tab 34 \tab 1.3 \tab 0.007 \tab 3 \tab | \tab -0.33 \tab -0.82 \tab 0.03 \tab -0.46\tab | \tab -0.395  \cr
2 \tab 23 \tab 4.6 \tab 0.267 \tab 4 \tab | \tab -1.12 \tab 0.34  \tab 1.04 \tab 0.0  \tab | \tab 0.065 \cr
3 \tab 56 \tab 7.2 \tab 0.07  \tab 7 \tab | \tab 1.27  \tab 1.26  \tab 0.28 \tab 1.39 \tab | \tab 1.05 \cr
4 \tab 41 \tab 1.4 \tab -0.35 \tab 2 \tab | \tab 0.18  \tab -0.79 \tab -1.35\tab -0.93\tab | \tab -0.723 \cr
... \tab ... \tab ... \tab ... \tab ... \tab |
\tab ... \tab ... \tab ... \tab ... \tab | \tab ... }

}

\subsection{Creating the groups}{
Finally, we create the groups with the numerical balancing in \code{\link[groupdata2:fold]{fold()}}
so the combined balancing column is balanced between them.

The following describes the numerical balancing:

TODO Replace num_col in the below as we are balancing the combined here!
\enumerate{
\item Rows are shuffled.
\strong{Note} that this will only affect rows with the same value in \code{`num_col`}.
\item Extreme pairing 1: Rows are ordered as \emph{smallest, largest, second smallest, second largest}, etc.
Each pair get a group identifier. (See \code{\link[rearrr:pair_extremes]{rearrr::pair_extremes()}})
\item If \code{`extreme_pairing_levels` > 1}: The group identifiers are reordered as \emph{smallest,
largest, second smallest, second largest}, etc., by the sum of \code{`num_col`} in the represented rows.
These pairs (of pairs) get a new set of group identifiers, and the process is repeated
\code{`extreme_pairing_levels`-2} times. Note that the group identifiers at the last level will represent
\code{2^`extreme_pairing_levels`} rows, why you should be careful when choosing that setting.
\item The final group identifiers are folded, and the fold identifiers are transferred to the rows.
}

N.B. When doing extreme pairing of an unequal number of rows,
the row with the smallest value is placed in a group by itself, and the order is instead:
smallest, \emph{second smallest, largest, third smallest, second largest}, etc.

\strong{Example}: We order the \code{data.frame} by smallest \emph{"Num"} value,
largest \emph{"Num"} value, second smallest, and so on.
We could (if \code{`extreme_pairing_levels` > 1})
find the sum of \emph{"Num"} for each pair and perform extreme pairing on the pairs.
Finally, we group the \code{data.frame}:

\tabular{rrrrrrrrrrrr}{
\strong{Group} \tab \strong{Num} \tab
\strong{->} \tab
\strong{Group} \tab \strong{Num} \tab
\strong{Pair} \tab \strong{->} \tab
\strong{New group}\cr
1 \tab -0.395\tab | \tab 4 \tab -0.723\tab 1 \tab | \tab 1 \cr
2 \tab 0.065 \tab | \tab 3 \tab 1.05  \tab 1 \tab | \tab 1  \cr
3 \tab 1.05  \tab | \tab 1 \tab -0.395\tab 2 \tab | \tab 2 \cr
4 \tab -0.723\tab | \tab 2 \tab 0.065 \tab 2 \tab | \tab 1 \cr
... \tab ... \tab | \tab ... \tab ... \tab ... \tab | \tab ... }

}
}
\examples{
# Attach packages
library(groupdata2)
library(dplyr)

# Create data frame
df <- data.frame(
  "participant" = factor(rep(c("1", "2", "3", "4", "5", "6"), 3)),
  "age" = rep(sample(c(1:100), 6), 3),
  "diagnosis" = factor(rep(c("a", "b", "a", "a", "b", "b"), 3)),
  "score" = sample(c(1:100), 3 * 6)
)
df <- df \%>\% arrange(participant)
df$session <- rep(c("1", "2", "3"), 6)
}
\seealso{
\code{\link[groupdata2:fold]{fold()}} for creating balanced folds/groups.

\code{\link[groupdata2:partition]{partition()}} for creating balanced partitions.

Other grouping functions: 
\code{\link{all_groups_identical}()},
\code{\link{collapse_groups_by}},
\code{\link{fold}()},
\code{\link{group_factor}()},
\code{\link{group}()},
\code{\link{partition}()},
\code{\link{splt}()}
}
\author{
Ludvig Renbo Olsen, \email{r-pkgs@ludvigolsen.dk}
}
\concept{grouping functions}
